import re, sys, os
import shutil
from fetch_leetcode_data import fetch_leetcode_data, extract_examples, extract_test_info, format_data

def extract_function_info(filename):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(script_dir)
    file_path = os.path.join(parent_dir, filename, f"{filename}.cpp")

    if not os.path.exists(file_path):
        print(f"Error: File {file_path} does not exist.")
        return None

    with open(file_path, 'r') as file:
        content = file.read()

    # Check if the replacement has already been done
    if "#ifdef LOCAL_TEST" in content:
        print(f"Class definition already modified in {file_path}. Skipping replacement.")
    else:
        # Insert the include statement above the `//@lc` comment
        include_statement = """#include "TestRunner.h" // Required file to build and run locally"""
        content = re.sub(r'(/\*.*?@lc.*?\*/)', r'\1\n' + include_statement, content, flags=re.DOTALL)

        # Replace the class Solution definition
        new_class_def = """#ifdef LOCAL_TEST
class Solution : public LeetCodeSolution
#else
class Solution
#endif 
{"""
        content = re.sub(r'class\s+Solution\s*{', new_class_def, content, flags=re.DOTALL)

        # Write the modified content back to the file
        with open(file_path, 'w') as file:
            file.write(content)
        print(f"Added testRunner definitions to {file_path}.")

    # More flexible regex to match the class definition
    class_pattern = re.compile(r'class\s+Solution(?:\s*:.*?)?\s*{(.*?)\s*public:\s*(.*?)\s*};', re.DOTALL)
    match = class_pattern.search(content)
    
    if not match:
        print(f"Error: Couldn't find class definition in {file_path}")
        return None
    
    class_content = match.group(2)  # Public section of the class
    function_pattern = re.compile(r'([\w<>]+)\s+(\w+)\s*\(([^)]*)\)')

    # Try to match
    match = function_pattern.search(class_content)    
    if not match:
        print(f"Error: Couldn't find function definition in class Solution in {file_path}")
        return None
    
    return_type, func_name, args = match.groups()
    
    # Clean up the args
    args = re.sub(r'\s*=\s*[^,)]+', '', args)  # Remove default arguments
    arg_list = [arg.strip().rsplit(' ', 1) for arg in args.split(',')] if args else []
    
    return return_type, func_name, arg_list

def generate_config(return_type, func_name, args):
    # Determine the necessary includes and using statements
    includes = ['#include <string>', '#include <tuple>']
    usings = ['using std::tuple;', 'using std::vector;']
    args_types = []
    for arg_type, arg_name in args:
        args_types.append(arg_type)
    
    if 'vector' in args or 'vector' in return_type:
        includes.append('#include <vector>')
        usings.append('using std::vector;')
    if 'list' in args or 'list' in return_type:
        includes.append('#include <list>')
        usings.append('using std::list;')
    if 'string' in args or 'string' in return_type:
        usings.append('using std::string;')
    if 'map' in args or 'map' in return_type:
        includes.append('#include <map>')
        usings.append('using std::map;')
    if 'set' in args or 'set' in return_type:
        includes.append('#include <set>')
        usings.append('using std::set;')
    if 'unordered_map' in args or 'unordered_map' in return_type:
        includes.append('#include <unordered_map>')
        usings.append('using std::unordered_map;')
    if 'unordered_set' in args or 'unordered_set' in return_type:
        includes.append('#include <unordered_set>')
        usings.append('using std::unordered_set;')
    if 'array' in args or 'array' in return_type:
        includes.append('#include <array>')
        usings.append('using std::array;')

    includes_str = '\n'.join(includes)
    usings_str = '\n'.join(usings)
    argstypes_str = ','.join(args_types)
    
    config = f"""// Configuration settings for the current test
// This file is generated by vscode on build - DO NOT EDIT

#pragma once

#define LOCAL_TEST
#define TEST_FUNC {func_name}

{includes_str}

{usings_str}

using test_return_type = {return_type};

using test_args_types = tuple<{argstypes_str}>;
"""

    config += f"""
struct TestCase {{
"""
    config += "\ttest_args_types args;\n"
    config += "\ttest_return_type expected;\n};"
    config += f"\n\nconst std::string test_name = \"{func_name}\";"

    return config


def copy_test_template(source_dir, dest_dir, filename, examples, description, constraints):
    source_path = os.path.join(source_dir, 'testTemplate.txt')
    dest_path = os.path.join(dest_dir, f'{filename}-tests.cpp')
    
    if not os.path.exists(dest_path):
        shutil.copy(source_path, dest_path)
        print(f"Created new test file: {dest_path}")
    else:
        print(f"Test file {dest_path} already exists. Skipping creation.")
    
    with open(dest_path, 'r') as file:
        lines = file.readlines()
    
    if len(lines) >= 3:
        lines[1] = f'#include "{filename}.cpp"\n'

        description_in_comment = f"\n/** ======================= DESCRIPTION ======================= \n * \n"
        for line in description.split('\n'):
            description_in_comment += f" * {line}\n" 
        description_in_comment += " * \n * Find examples below in `std::vector<TestCase> testCases` \n * \n * Constraints: \n"
        
        constraints_in_comment = ''
        for line in constraints.split("\n"):
            constraints_in_comment += f" *  â€¢ {line}\n"

        description_comment = description_in_comment + constraints_in_comment + " */ \n\n"

        lines.insert(2, description_comment)

        test_cases_index = next(i for i, line in enumerate(lines) if 'std::vector<TestCase> testCases' in line) + 7
        lines.insert(test_cases_index, " \t// Examples prefilled from Leetcode: \n\n")
        test_cases_index += 1

        for i, (input_data, output_data, explanation) in enumerate(examples):
            test_case = f"    // Example {i + 1}\n" + "    {\n"
            test_case += f"        {format_data(input_data)},  // Input\n"
            test_case += f"        {format_data(output_data)}   // Expected Output\n"
            test_case += "\n        /* Explanation: \n"
            for line in explanation:
                test_case += f"        - {line}\n"
            test_case += "        */\n    },\n\n"
            lines.insert(test_cases_index, test_case)
            test_cases_index += 1
        
        with open(dest_path, 'w') as file:
            file.writelines(lines)
        print(f"Added test cases from leetcode to {dest_path}")
    else:
        print(f"Warning: {dest_path} has less than 3 lines. File not updated.")


def get_last_processed_file(config_dir):
    last_file_path = os.path.join(config_dir, '.last_processed')
    if os.path.exists(last_file_path):
        with open(last_file_path, 'r') as f:
            return f.read().strip()
    return None

def set_last_processed_file(config_dir, filename):
    last_file_path = os.path.join(config_dir, '.last_processed')
    with open(last_file_path, 'w') as f:
        f.write(filename)

def test_file_already_generated(dest_dir, filename):
    test_file_path = os.path.join(dest_dir, f'{filename}-tests.cpp')
    if not os.path.exists(test_file_path):
        return False
    
    with open(test_file_path, 'r') as file:
        lines = file.readlines()
    
    if len(lines) >= 3 and lines[1].strip() == f'#include "{filename}.cpp"':
        print(f"Test file {filename}-tests.cpp has already been generated. Skipping generation")
        return True
    
    return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python script.py <filename>")
        sys.exit(1)
    
    filename = sys.argv[1]
    title_slug = re.sub(r'^\d+\.', '', filename)
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(script_dir)
    config_dir = os.path.join(parent_dir, 'include')
    
    last_processed = get_last_processed_file(script_dir)
    
    # Check if the file has been modified since the last run
    file_path = os.path.join(parent_dir, filename, f"{filename}.cpp")
    if last_processed == filename and "#ifdef LOCAL_TEST" in open(file_path).read():
        print(f"Config for {filename} is already up to date. Skipping regeneration.")
        sys.exit(0)
    
    result = extract_function_info(filename)
    
    if result:
        return_type, func_name, args = result
        config = generate_config(return_type, func_name, args)
        
        # Write to config.h
        config_path = os.path.join(config_dir, 'config.h')
        
        with open(config_path, 'w') as file:
            file.write(config)
        print(f"Config written to {config_path}")
        
        if not test_file_already_generated(os.path.join(parent_dir, filename), filename):
            print("\nFetching test data from Leetcode...")
            data = fetch_leetcode_data(title_slug)
            content = data['data']['question']['content']
            examples = extract_examples(content)    
            description, constraints = extract_test_info(content, line_length=80)    

            # Copy test template and update include statement
            source_dir = config_dir
            dest_dir = os.path.join(parent_dir, filename)
            copy_test_template(source_dir, dest_dir, filename, examples, description, constraints)
        
        # Update last processed file
        set_last_processed_file(config_dir, filename)
    else:
        sys.exit(1)
